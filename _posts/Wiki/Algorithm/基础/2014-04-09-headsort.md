---
layout: post
title: 堆排序
category: Wiki
tags: 基础
type: Algorithm
isUseGitComment: true
isUseDisqusComment: false
---

### 堆排序是一种很神奇的排序
##### [参考博客](//blog.csdn.net/xiaoxiaoxuewen/article/details/7570621)

这里使用的是最大堆的算法,堆排序的思想就是先将给定的序列构造成完全二叉树,然后对这棵二叉树的非叶子节点进行调整
,就是将每一个非叶子与其子节点进行比较,不断的递归使得每一个非叶子节点都比其子节点大已达到最大堆,步骤如下:

+ 建立最大堆,从最后一个非叶子节点开始进行堆调整
+ 在堆调整的过程中,先将当前节点与左节点进行比较,更新最大值的位置,再与右节点进行比较,更新最大值的位置,如果最大值为当前节点本身,则说明这个地方是满足最大堆的,返回,若最大值的的位置有所更新,则交换当前节点与该最大值位置的值,然后对新的最大值位置进行堆调整
+ 建完堆后,即可开始堆排序,堆排序的过程其实就是不断的将堆顶元素与最后一个元素进行交换,然后最新的序列进行最大堆调整,因为每次被换的是堆顶元素,所以每次调整时直接从堆顶位置1开始进行调整就好了
+ 排完序后原序列已经更新,输出即可(下面的代码建立的堆的堆顶元素位置从1开始,所以原序列的值从位置1开始)


		#include <iostream>
		#include <cmath>
		using namespace std;

		/*
			堆调整,每一次通过传入需要调整的位置和当前序列长度
		*/
		void heapAdjust(int a[], int pos, int size)
		{
			int lNode = pos * 2;     //获取该节点的左节点位置
			int rNode = pos * 2 + 1; //获取该节点的右节点的位置
			int max = pos;           //因为要调整为最大堆,所以先假定最大值为当前节点
			/*
				如果是非叶子节点的话就进行调整,因为叶子节点已经没有可以比较的子节点
			*/
			if ( pos <= size/2)
			{
				if (lNode <= size && a[lNode] > a[max])
				{
					max = lNode;
				}
				if (rNode <= size && a[rNode] > a[max])
				{
					max = rNode;
				}
				if (max != pos)
				{
					//每次调整完以后,在对新的节点位置进行调整,因为每次调整都可能会改变原来的满足堆
					swap(a[max], a[pos]);
					heapAdjust(a, max, size);
				}
			}
		}
		/*
			建立堆,这里建的是最大堆,建堆的过程其实就是建立二叉树的过程
			即不断的调整非叶子节点的值,在序列中非叶子节点的位置为<=size/2
		*/
		void buildHeap(int a[], int size)
		{
			for (int i = size/2; i >= 1 ; --i)
			{
				heapAdjust(a, i, size); //对每一个非叶子节点进行调整以生成最大堆
			}
		}

		/*
			堆排序,当最大堆建好以后,所谓的排序就是每次都将堆顶元素与最后一个元素交换,这样最大的元素
			就会下沉到尾端,然后在对新的队列进行最大堆调整,重复这个过程直到序列中只剩下一个元素
		*/
		void heapSort(int a[], int size)
		{
			buildHeap(a, size); //先建堆
			for (int i = size; i >= 1 ; --i)
			{
				swap(a[1], a[size]);       //每次都将堆顶元素与最后一个元素交换
				heapAdjust(a, 1, --size);  //交换完以后,堆变成不满足,重新调整成为最大堆,此刻序列中只剩下size-1个元素了
			}
		}

		int main()
		{
			int a[11] = {0,8, 1, 4, 9, 6, 3, 5, 2, 7, 0};
			heapSort(a, 10);
			for (int i = 1; i <= 10; ++i)
			{
				cout << a[i] << ", ";
			}
			cout << endl;
			getchar();
		}