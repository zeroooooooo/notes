---
layout: post
title: Dijkstra算法
category: Wiki
tags: 基础
type: Algorithm
isUseGitComment: true
isUseDisqusComment: false
---

### Dijkstra算法的基本思想

Dijkstra算法的基本思想其实就是,通过与起点链接的最短距离的点去更新其他的点的位置,这样到最后更新完后就可以得到一个存储起点到其他各个点的最短距离的数组,步骤如下:

+ 初始化的过程是将存储答案的数组初始化为与起点有相连的设为权重,不相连的置为无穷,还有done数组全部置为0
+ 从点1开始对图中所有的点进行遍历起初与起点距离最短的点,将这个位置的done置为1,即表示这个点已经完成
+ 接下来通过上面得到的与起点距离最短的点对其他的点的位置进行位置更新,如果起点到这个点的距离大于起点通过步骤2得到的点再到这个点的距离,则将起点到这个点的距离更新为后者的值
+ 得到存储结果的数组,输出即可


		#include <iostream>
		#include <vector>
		using namespace std;
		#define MAXVEX 9
		#define INFINITY 65535

		void dijkstra(vector<int> ver[], int begin, int size, int ans[])
		{
			int vexNode, weight, pos, min;
			int done[MAXVEX];

			/*
				初始化,done数组记录的是已经从起点到某一点的最短距离是否求出,若是为1,不是为0
				所以一开始初始化时全部都为0,然后存储结果的ans数组存储的是起点到其他点的最短距离值
				所以初始化时,先将与起点有链接的点的距离设为其之间的权重,其他不相连的值设为无穷
			*/
			for (int i = 0; i < size; ++i)
			{
				done[i] = 0;
				ans[i] = ver[begin][i];
			}
			//因为起点到起点的最短距离是0所以初始化为0,同时起点到起点的最短距离已经求出,所以done置为1
			ans[begin] = 0;
			done[begin] = 1;

			//初始化完成后,即可开始进入下面的循环,循环的作用就是不断更新其他点到起点的距离直到最短
			for (vexNode = 1; vexNode < size; ++vexNode)
			{
				//第一个循环的作用是在与起点相连的点中找出距离最短的点,目的是要利用这个点来更新其他点的位置信息
				min = INFINITY;
				for (weight = 0; weight < size; ++weight)
				{
					if (!done[weight] && ans[weight] < min)
					{
						pos = weight;
						min = ans[weight];
					}
				}
				//找出与起点距离最短的点后,这个点的就完成了,即done[pos]置为1
				done[pos] = 1;

				//循环二的作用是通过前面得到的与起点距离最短的点来对其他的点的位置进行更新
				for (weight = 0; weight < size; ++weight)
				{
					if (!done[weight] && min + ver[pos][weight] < ans[weight] )
					{
						ans[weight] = min + ver[pos][weight];
					}
				}
			}
		}

		int main()
		{
			vector<int> a[INFINITY];
			int from, to, weight;
			int n, m;
			cin >> n;
			m = n;
			for (int i = 0; i < n; ++i)
			{
				for (int j = 0; j < n; ++j)
				{
					if ( i != j )
					{
						a[i].push_back(INFINITY);
					}
					else
					{
						a[i].push_back(0);
					}
				}
			}

			while( m-- )
			{
				cin >> from >> to >> weight;
				a[from][to] = weight;
			}
			int ans[100];
			dijstra(a, 0, n, ans);
			for (int i = 0; i < n; ++i)
			{
				cout << ans [i] << " ";
			}
			cout << endl;
			getchar();
			cin >> n;
			return 0;
		}