---
layout: post
title: Prim算法
category: Wiki
tags: 基础
type: Algorithm
---

### Prim算法的基本思想

Prim算法的基本思想是通过以一个点为起点比如v0开始,然后搜寻与v0相连的点,找出与其边距最短的点作为下一个加入做小生成树的点,然后就生成新的集合{v0, vx, ...},没找到一个新的点,就再以这个点为中介向四周扩散,即通过以这个新点为中介将原先存储各点与v0的距离值进行比较,更新这个数组,然后再以新的距离数组重复上面的过程,步骤如下:

+ 初始化存储各点到v0的距离,若距离存储为0的则表示该点已经纳入最小生成树
+ 遍历当前的距离数组(除去值为0的点)找出与v0距离最短的点作为新的加入最小生成树的点,记录该点的位置k
+ 将距离数组的k位置的值置为0表示k已经加入最小生成树
+ 再一次遍历距离数组,不过此次以k位置作为中介将原值与a[k][j]进行比较,更新距离数组
+ 重复2-4的过程直到点全部加入最小生成树中

		#include <iostream>
		#include <vector>
		#define MAXVEX 9
		#define INFINITY 65535
		using namespace std;

		vector<int> ans;
		void prim(vector<int> a[], int nodeNum)
		{
			/*
				使用lowcost数组记录图中的点是否已经加入最小生成树中,为0的时候即是已经加入了最小生成树中
			*/
			int lowcost[MAXVEX] = {0}; 
			int path[MAXVEX] = {0};  //用来存储最小生成树生成过程中的边选择

			/*
				首先进行初始化,以v0为起点,从v1开始将所有点与v0的距离存入lowcost中,若与v0相连则输入其边的权重,若没有则存为无穷
			*/
			for (int i = 1; i < nodeNum; ++i)
			{
				lowcost[i] = a[0][i];
				path[i] = 0;              //一开始以v0为起点所以先初始化为0
			}

			/**/
			for (int i = 1; i < nodeNum; ++i)
			{
				int min = INFINITY;

				//找出与{v0}点相连的最短的点
				int j = 1, k = 0;
				while( j < nodeNum )
				{
					if (lowcost[j] != 0 && lowcost[j] < min)
					{
						min = lowcost[j];
						k = j;
					}
					j++;
				}
				//找到与v0点距离最短的点以后将该点加入最小生成树中,即将lowcost[k]置为0
				lowcost[k] = 0;
				ans.push_back(k);

				cout << path[k] << " " << k << endl;  //输出from->to的边加入最小生成树

				//将新的点加入最小生成树后,以该点为中介将原先的lowcost数组的值与通过新点链接的点的距离进行比较
				//更新lowcost的值,同时比较过程中,lowcost为0的点不加入比较,因为他们已经属于最小生成树的一员了
				for (int j = 1; j < nodeNum ; ++j)
				{
					if (lowcost[j] != 0 && a[k][j] < lowcost[j])
					{
						lowcost[j] = a[k][j];
						// cout << lowcost[j] << " **** " << endl;
						path[j] = k;                //更新路径记录的联通情况
					}
				}
			}

		}

		int main()
		{
			vector<int> a[100];

			int n, m, from, to, weight;
			cin >> n >> m;
			ans.push_back(0);
			for (int i = 0; i < n; ++i)
			{
				for (int j = 0; j < n; ++j)
				{
					if ( i != j )
					{
						a[i].push_back(INFINITY);
					}
					else
					{
						a[i].push_back(0);
					}
				}
			}

			while( m-- )
			{
				cin >> from >> to >> weight;
				a[from][to] = weight;
				a[to][from] = weight;
			}

			for (int i = 0; i < n; ++i)
			{
				for (int j = 0; j < n; ++j)
				{
					cout << a[i][j] << " ";
				}
				cout << endl;
			}
			prim(a, n);

			for (int i = 0; i < ans.size(); ++i)
			{
				cout << ans[i] << " -> ";
			}

			cout << endl;

			getchar();
			cin >> n;
			return 0;

		}