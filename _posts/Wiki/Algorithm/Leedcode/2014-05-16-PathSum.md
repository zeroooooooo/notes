---
layout: post
title: Path Sum
category: Wiki
tags: Leecode
type: Algorithm
---

### 题目

[原题: ](//oj.leetcode.com/problems/path-sum/)Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

<b>For example:</b>

        Given the below binary tree and sum = 22,
              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1
        return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.

<b>题意: </b>从给定二叉树中查看是否存在从根节点到叶子节点的路径和等于给定的数

### 思路
递归遍历二叉树,如果是叶子节点就判断当前节点的值加上之前路径的和是否等于给定数.只要给定数出现在左子树或者是右子树都返回true.

###### 代码

		bool pathSum(TreeNode *root, int sum, int curSum)
        {
            if(root == NULL)
            {
                return false;
            }
            
            if(root->left == NULL && root->right == NULL)
            {
                return sum == curSum + root->val;
            }
            
            return pathSum(root->left, sum, curSum+root->val) || pathSum(root->right, sum, curSum+root->val);
        }
        bool hasPathSum(TreeNode *root, int sum) 
        {
            return pathSum(root, sum, 0);
        }

###### 代码(记录路径)
        
        void findPathSum(TreeNode *root, int sum, vector<vector<int> > &ans, vector<int>temp, int curSum)
        {
            if(root == NULL)
            {
                return;
            }
            if(root->left == NULL && root->right == NULL)
            {
                if(curSum + root->val == sum)
                {
                    temp.push_back(root->val);
                    ans.push_back(temp);
                }
                return;
            }
            temp.push_back(root->val);
            
            findPathSum(root->left, sum, ans, temp, curSum+root->val);
            findPathSum(root->right, sum, ans, temp, curSum+root->val);
        }
        vector<vector<int> > pathSum(TreeNode *root, int sum) 
        {
            vector<vector<int> >ans;
            vector<int> temp;
            findPathSum(root, sum, ans, temp, 0);
            return ans;
        }