---
layout: post
title: Javascript面向对象
category: Wiki
tags: Javascript
type: FE
isUseGitComment: true
isUseDisqusComment: false
---

### 定义对象的方式

		##可以这样
		var per = new Object();
		per.name = "vin";
		per.age = 1;

		per.sayhello = function()      //定义对象的方法
		{
		    alert(this.name);
		}

		##或者
		var per = {
		    name: "vin",
		    age: 2,

		    sayHello: function()
		    {
		        alert(this.name);
		    }
		};

### 定义访问器
 
		##在新版本中可以如下定义访问器:
		var book = {
		    _year : 2014,     //前面有_符号表示只能通过类的方法访问
		    name : "vin"
		}

		Object.defineProperty(book, "year",{
		    get: function()
		    {
		        return this._year;
		    }
		    set: function(newValue)
		    {
		        this._year = newValue;
		    }
		});

		##在旧版本中如下定义访问器:
		book._defineGetter_("year", function(){
		    return this._year;
		});
		book._defineSetter_("year", function(newValue){
		    this._year = newValue;
		});

		##在新版本中可以如下定义拥有多个属性的对象
		var book = {};
		Object.defineProperties(book, {
		    _year:{
		        value: 2014
		    },
		    name:{
		        value: "vin"
		    },
		    year: {
		        get:function()
		        {
		            return this._year;
		        }

		        set: function()
		        {
		            this._year = 2008;
		            this.name = "hehe";
		        }
		    }
		});

### 创建对象

+ ###### 工厂模式(通过一个函数来创建对象和对象的各种接口)
		function createPerson(name, age, job)
		{
		    var o = new Object();
		    o.name = name;
		    o.age = age;
		    a.job = job;

		    o.sayHello = function()
		    {
		        alert("hehe");
		    };

		    return o;
		}

		var p1 = createperson("a", 1, "b");

+ ##### 构造函数模式(名称首字母大写):

		function Person(name, age, job)
		{
		    this.name = name;
		    this.age = age;
		    this.job = job;

		    this.sayHello = function()    //导致了没创建一个实例就会创建一个函数
		    {
		        alert("hehe");
		    };

		    //通过在里面定义在外面实现方式可以解决上面的问题,但是就不能体现出封装性
		    this.sayHello = sayHello;  
		}

		function sayHello()
		{
		    alert("hehe");
		}

		var p1 = new Person("a", 1, "b");

+ ##### 原型模式:

		function person() = {}

		Person.prototype.name = "vin";
		Person.prototype.age = 1;

		Person.prototype.sayHello = function()
		{
		    alert(this.name);
		};

		##可以将其简化为下面的方法:
		Person.prototype = {
		    name: "vin",
		    age: 1,
		    friends:["vin", "nannan"], //属性中存在数组属性时,因为在原型模式中属性是共有的,这样就存在缺陷

		    sayHello : function()
		    {
		        alert("hehe");
		    }
		};

+ ##### 构造函数模式和原型模式:
 
		function Person(name, age, job)    //这样子每一个实例都有自己独立的属性集
		{
		    this.name = name;
		    this.age = age;
		    this.job = job;
		    this.friends = ["vin", "nannan"];
		}

		Person.prototype = {              //同时有共享方法
		    constructor : Person,
		    sayHello : function(){
		        alert("hehe");
		    }
		}

+ ##### 动态原型模式:

		function Person(name, age, job)   //这样就可将属性和方法都封装起来    
		{
		    //属性
		    this.name = name;
		    this.age = age;
		    this.job = job;
		    this.friends = ["vin", "nannan"];

		    if(typeof this.sayHello != "function")  //第一次调用构造函数时执行
		    {
		        Person.prototype.sayHello = function()
		        {
		            alert("hehe");
		        };
		    }
		}   

### 继承
 
		##组合继承:
		function SuperType(name){
		    this.name = name;
		    this.color = ["green", "blue", "sky"];
		}

		SuperType.prototype.sayName = function(){
		    alert(this.name);
		};

		function SubType(name, age){

		    //继承属性
		    SuperType.call(this, name);
		    this.age = age;
		}

		//继承方法
		SubType.prototype = new SuperType();
		SubType.prototype.sayAge = function(){
		    alert(this.age);
		};
